---
title: "Corona Sweeper"
author: "Kate Saunders"
date: "17/05/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(knitr)
library(kableExtra)
```

# Game Design {.tabset}

## Game Rules

### Game Summary

The goal of the game is to use testing to discover people within the population who are infected, and to stop the virus spreading.  Hidden infectious people will be revealed to you if (i) you find them via testing, or (ii) they develop symptoms. 
<!-- A person will be revealed as infected in two cases, if (i) they are tested, or (ii) they develop symptoms.  -->
You will be able to test if a person has the virus using a mouse click. If they are infected they will go into quarantine along with their four closest neighbours. 

Each new mouse click also starts a new day. Upon each new day, undiscovered infectious people within the population can infect others. In addition to testing, to help you discover these people, if a person develops symptoms they are automatically quarantined along with their direct neighbours. Once in quarantine a person can't infect anyone else. 
<!-- People who have been exhibiting symptoms will also eventually transition to the recovered state. Recovered people can not catch the virus again or infect others. -->

You win the game by finding and quarantining all infections through the use of testing. You lose the game though if the virus takes off in the population and over half of the people contract the virus.

### Virus Behaviour

For this game, a person is classfied as one of following infectious states:
```{r echo = FALSE}
infection_levels = c("S", "I", "R")
infection_labels = c("Susceptible", "Infected", "Recovered")
infection_description = c("Can catch the virus", "Has caught the virus", 
                          "No longer has the virus")
infection_table = data.frame("Label" = infection_labels, 
                             "Letter" = infection_levels, 
                             "Description" = infection_description)
kable(infection_table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

If a person who is susceptible comes into contact with an infected person they have a chance of catching the virus. If the person catches the virus then their status changes to infected. People who no longer have the the virus are considered recovered. Once a person has recovered they don't return to a susceptible state and can not become infected again. Labelling the state as recovered avoids including a mortality state. 

### Quaratine 

There is a fourth state a person can be, the exposed state. Exposed people, have come into contact with an infected person, but don't know yet if this exposure has caused them to catch the virus. To prevent the spread of the virus, anyone exposed to the virus is automatically quarantined. 

### Hidden Infections

The game begins with four randomly chosen people who are infected but their infection status is hidden. Until these hidden infectious people are found and quarantined, they will continue to lead to new infections and the virus will spread.

### Catching the Virus

A susceptible person can catch the virus from an infected person who is a neighbour. As the game is played in a grid neighbours are people left, right, top and bottom. 

Infections occur based on a random trial. For example, a susceptible person might catch the virus from their expected neighbour with a 1 in 5 chance. Changing this probility of infection makes the game easier or harder. Infections also occur independently of each other, so if two neighbours are infected, than a susceptible person is twice as likely to catch the virus.

<!-- The easy game level decreases the probablity of infection to roughly a 1 in 8, and to the make the game harder the probability of infection is increased to roughly a 1 in 4. -->

Also to keep things interesting the board wraps top to bottom and left to right. A person in the bottom row can infect therefore their equivalent neighbour in the top row and vice versa. Similarly a person in the far left column can infect their equivalent neighbour in the far right column, and vice versa.


### Testing

To stop the virus spreading, testing can be used to find the hidden people in the population who are infected. A tested person who is revealed as infected is automatically quarantined along with their neighbours. Careful however, a person who was tested today and doesn't have the virus can still get infected at some time in the future. It therefore may be necessary to test a person more than once.

### Symptoms and Recovery

In addition to testing, a person is revealed as infected and quarantined if they start showing symptoms. On average the WHO says symptoms will show after 6 days. 
https://www.who.int/emergencies/diseases/novel-coronavirus-2019/question-and-answers-hub/q-a-detail/q-a-coronaviruses
In the game, a person will therefore show symptoms after a random number of days, with the average time until symptoms being 6 days. Once symptoms are revealed, that person and their four neighbours are quarantined.
<!-- For the game to mirror the virus characteristics, there should be a period of time before an infected person will show symptoms.  -->

The WHO also says people with mild cases are expected to recover within two weeks
https://www.who.int/dg/speeches/detail/who-director-general-s-opening-remarks-at-the-media-briefing-on-covid-19---24-february-2020
Similarly, the number of days until a person recovers is randomly simulated, with an average recovery period of 14 days. 

## R Set Up 

This section provides the R code needed to initialise the game variables and parameters. 

### Contact Network

We store all the information about the people in a data frame called `init_data`, including details about a person's infection status, quarantine status and test status. This data frame also gives the location of people within a grid. This grid forms the game board and the contact network.
```{r}
# board dimensions (rows by columns)
I = 20; J = 20;

# initialise the board
init_data <- expand.grid(X = 1:I, Y = 1:J) %>% as.data.frame()
```

### Infectious Status

There is a column for a person's known infection status, and to start everyone in labelled as susceptible. 

```{r}
infection_levels = c("S", "I", "R")
infection_labels = c("Susceptible", "Infected", "Recovered")
init_data$shown = rep("S", nrow(init_data))
```

### Hidden Infectious Status

There is another column that stores the hidden infectious status. In the beginning of the game, four people are randomly set to be infectious. 

```{r eval = FALSE}
start_num_infections = 4 
init_data$hidden <- rep("S", I*J) 
initial_infections <- sample(1:(I*J), start_num_infections)
init_data$hidden[initial_infections] <- "I"
```

### Quarantine Status

Everyone begins the game not in quarantine.

```{r}
quarantine_levels = c("Yes", "No")
quarantine_labels = c("Quarantined", "No Restrictions")
init_data$quarantined <- rep("No", I*J)
```

### Testing 

Everybody begins the game as untested. 

```{r}
test_levels = c("tested", "unknown")
test_labels = c("Tested", "Not Tested")
init_data$tested <- rep("unknown", I*J)
```

### Infection Period

We also store a variable called infection time. This will be used to keep track of when a person becomes infected, when their symptoms will be revealed and when they will recover. The infection time is not shown the game player and is for internal use only. At the beginning of the game, before any days have passed, the infection period is set to zero.

```{r eval = FALSE}
# Infection time
init_data$infection_period <- rep(NA, I*J)
init_data$infection_period[initial_infections] <- 0
```

### Symptoms and recovery

The time until the symptoms arrive and the time until a patient recovery is randomly simulated. For this we use Poisson random variables. These variables may not be used for some people as not everyone will get infected, however it simplifies things to initialise these symtpom and recovery variables for everyone before the game starts.

```{r eval = FALSE}
symptom_lambda = 5
init_data$symptom_time <- rpois(I*J, lambda = symptom_lambda)

recovery_lambda = 14
init_data$recovery_time <- init_data$symptom_time + rpois(I*J, lambda = recovery_lambda)
```

### Neighbours

For both simulating infections and quarantine it is useful to have a function to get the four closest neighbours. A couple of important points are: 

* The board positions are stored as vector 
* The grid cells are vectorised by column first then rows
* The board wraps like a taurus, so the top row neighbours the bottom row, and the far left row neighbours the far right row. 

The `get_neighbours()` function takes a location with the vector that indexes the grid/game board, and returns the vectorised positions of its neighbours. Note within this function, the later part of each `*_nbr` equation addresses the grid wrapping and deals with the boundary cases.
```{r}
get_neighbours <- function(i, I, J){
  row_index = i%%I + I*(i%%I == 0); 
  col_index = ceiling(i/I)
  left_nbr   = i - I + (col_index == 1)*(I*J)
  right_nbr  = i + I - (col_index == J)*(I*J)
  top_nbr    = i - 1 + (row_index == 1)*I
  bottom_nbr = i + 1 - (row_index == I)*I
  nbrs <- c(left_nbr, right_nbr, top_nbr, bottom_nbr)
  return(nbrs)
}
```

### Next Steps

The next step is to set up the game board. After this, how the mouse click influences the game dynamics can be explained. 

## Board Design

Below is the code needed to create the `ggplot` game board. Hopefully, it looks clean and simple, but it actually took some thinking!

<!-- Code Summary from previous tabset  -->
```{r echo = FALSE}
# board parameters
I = 20; J = 20;

# initialise the board
init_data <- expand.grid(X = 1:I, Y = 1:J) %>% as.data.frame()

# infectious status
infection_levels = c("S", "I", "R")
infection_labels = c("Susceptible", "Infected", "Recovered")
init_data$shown = rep("S", nrow(init_data))

# hidden infectious status
start_num_infections = 4 
init_data$hidden <- rep("S", I*J) 
initial_infections <- sample(1:(I*J), start_num_infections)
init_data$hidden[initial_infections] <- "I"

# quarantine status
quarantine_levels = c("Yes", "No")
quarantine_labels = c("Quarantined", "No Restrictions")
init_data$quarantined <- rep("No", I*J)

# testing status
test_levels = c("tested", "unknown")
test_labels = c("Tested", "Not Tested")
init_data$tested <- rep("unknown", I*J)

# infection period
init_data$infection_period <- rep(NA, I*J)
init_data$infection_period[initial_infections] <- 0

# symptoms period
symptom_lambda = 5
init_data$symptom_time <- rpois(I*J, lambda = symptom_lambda)

# recovery period
recovery_lambda = 14
init_data$recovery_time <- init_data$symptom_time + rpois(I*J, lambda = recovery_lambda)

# neighbour function

get_neighbours <- function(i, I, J){
  row_index = i%%I + I*(i%%I == 0); 
  col_index = ceiling(i/I)
  left_nbr   = i - I + (col_index == 1)*(I*J)
  right_nbr  = i + I - (col_index == J)*(I*J)
  top_nbr    = i - 1 + (row_index == 1)*I
  bottom_nbr = i + 1 - (row_index == I)*I
  nbrs <- c(left_nbr, right_nbr, top_nbr, bottom_nbr)
  return(nbrs)
}
```

### Board

The board is designed to resemble the standard minesweeper board. This can be achieved in a range of ways, but here grid coordinates are plotted used `geom_point()` and a square shape, `shape = 15`. 
```{r}
# plot the board
pnt_size = 3
ggplot(data = init_data) +
    geom_point(aes(x = X, y = Y), col = "gray", shape = 15, size = pnt_size + 2) 
```

### Infectious Status

Each person will be visualised using `geom_point()` and a circle, `shape = 15` and the colour of this circle will show their susceptibility state. To show how the visualisation works, one person in the centre of the board is set as infected.
```{r}
# infected example
centre_cell = I*(J/2) + J/2
init_data$shown[centre_cell] = "I"

# for the plot legend
init_data$shown <- factor(init_data$shown, levels = infection_levels)

# plot the board with susceptible states
ggplot(data = init_data) +
  geom_point(aes(x = X, y = Y), col = "gray", shape = 15, size = pnt_size + 2) +
  geom_point(aes(X, Y, fill = shown), shape = 21, size = pnt_size) +
  scale_fill_manual("INFECTION STATUS", labels = infection_labels,
                      values = c("S" = "gray", "I" = "red", "R" = "blue"), 
                      drop = FALSE) 
```

At the beginning of the game not all susceptible states will be visible. We want to keep the legend constant and to show all possible states at all times. This is why we convert the `shown` state to a factor instead of a string, and use `drop = FALSE` when we create our legend.

You might also notice, there is both a levels and labels vector. The levels are for to keep the internal code concise and clear, and the labels are for what will appear in the plot legend.  

### Quaratine 

We will use the undelying grid squares to show if a person is in quarantine or not. These squares are made slightly transparent using `alpha` so the susceptible state is clearly distinguishable from the quarantine state. Again as an example, the infected central cell is quarantined along with its neighbours.
```{r}
# quarantine example
nbrs = get_neighbours(centre_cell, I, J)
init_data$quarantined[c(centre_cell, nbrs)] = "Yes"

# for the plot legend
init_data$quarantined <- factor(init_data$quarantined, levels = quarantine_levels)

# plot the board with susceptible and quarantine states
ggplot(data = init_data) +
    geom_point(aes(x = X, y = Y, col = quarantined), 
               shape = 15, size = pnt_size + 2, alpha = 0.8) +
    scale_color_manual("EXPOSURE STATUS", labels = quarantine_labels,
                         values = c("No" = "lightgray", "Yes" = "coral"),
                         drop = FALSE) +
    geom_point(aes(X, Y, fill = shown), shape = 21, size = pnt_size) +
    scale_fill_manual("INFECTION STATUS", labels = infection_labels,
                        values = c("S" = "gray", "I" = "red", "R" = "blue"), 
                        drop = FALSE) 
```

### Testing

We also need to visualise if a person has been tested we use `geom_point()` and a circle with a cross, `shape = 13`. If a person hasn't been tested it just appears as the normal black circle outline, `shape = 1`.
```{r}
# test example
init_data$tested[centre_cell] = "tested"

# for the plot legend
init_data$tested <- factor(init_data$tested, levels = test_levels)

# plot the board with susceptible, quarantine and test states
board <- ggplot(data = init_data) +
    geom_point(aes(x = X, y = Y, col = quarantined), shape = 15, 
               size = pnt_size + 2, alpha = 0.8) +
    scale_color_manual("EXPOSURE STATUS", labels = quarantine_labels,
                         values = c("No" = "lightgray", "Yes" = "coral"),
                         drop = FALSE) +
    geom_point(aes(X, Y, fill = shown), shape = 21, size = pnt_size) +
    scale_fill_manual("INFECTION STATUS", labels = infection_labels,
                        values = c("S" = "gray", "I" = "red", "R" = "blue"), 
                        drop = FALSE) +
    geom_point(aes(X, Y, shape = tested), size = pnt_size, stroke = 1) +
    scale_shape_manual("TEST STATUS", labels = test_labels,
                         values = c("unknown" = 1, "tested" = 13),
                         drop = FALSE) 
board
```

### Tweaking the aesthetics 

At this point it is worth noting that the symbols have been carefully selected so all three states can be visualised simultaneously; exposure (colour), susceptibility (fill) and test (shape). Also note that the order the `geom_point()` calls are included is important for the order in which they are layered.

A few small fixes also make the game much more aesthetically pleasing

* `coord_fixed()` will ensure the geom_shape() will display as squares. 
* `theme_minimal()` is a cleaner and more simplistic theme
* `axis.*()` can be used to remove the axes text and labels
* `legend.*()` can be used to change the legend position and text
* `guides()` can be used to order the position of the legend elements

Positioning the legend at the bottom improves the display on mobile devices. 
```{r}
board <- board + 
  coord_fixed() +
      theme_minimal() +
      theme(
        axis.text = element_blank(), axis.title = element_blank(),
        legend.position = "bottom", legend.box = "vertical",
        legend.title = element_blank(), legend.text = element_text(size = 14)) +
      guides(fill = guide_legend(order=1),
              col = guide_legend(order=2),
              shape = guide_legend(order=3))
board
```

## Interactivity

With each new plot click the following must happen:

* Get test coordinate
* Increase counter on infection period
* Get possible exposures
* Update infections
* Reveal those with symptoms
* Reveal those who recovered
* Reveal status of the person tested
* Quarantine those exposed
* Label those exposed

### Catching the virus (REWRITE THIS BIT)

A susceptible person can catch the virus from an infected person. 
<!-- New infections can only happen between people who are not quarantined.  -->
Below we have set the probability of infection to 1/4. So we expect on average one of the four neighbours will be infected. This is of course random, so in practice none of the neighbours could get infected or all of them could. This is part of what makes the game interesting!

```{r eval = FALSE}
 # Update with new infections
  
  # Get locations of infected people who can infect others
    possible_virus_transmitters = which(init_data$hidden == "I" & init_data$quarantined == "No") 

  # Find the possible contacts who might be newly infected
    already_quarantined = which(init_data$quarantined == "Yes")
    exceptions = c(possible_virus_transmitters, already_quarantined)
    contacts = setdiff(neighbours, exceptions)
    
  # Get new infections  
    setup = data.frame(prob = 1/4)
    new_infections = rbinom(length(contacts), 1, setup$prob)
    infected_contacts = contacts[which(new_infections == 1)]
    
  # Update susceptible status in data frame  
    init_data$hidden[infected_contacts] = "I"
    init_data$infection_period[infected_contacts]  = -1
```

In probability, how an infection occurs between a susceptible and infected person is modelled using a Bernoulli random variable. Bernoulli variables have two possible outcomes, ie. heads or tails, yes or no, true or false. In our case, infected or not infected. If you are performing multiple Bernoulli trials, then we model this using a binonmial variable, ie how many heads in 10 coin flips, or how many infections occur in the four neighbours. This is what the function `rbinom()` does.



Before we get too much futher into game design, I think its important to review the shiny basics needed to create the interactivity. I will not cover shiny in a comprehensive way, for that I would highly recommend these [tutorials](  https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/). Instead I will present code snippets in their simplest form that will parallel the interactivity required.

### Basic Plot Set Up 

Shiny needs two core functions to work, a User Interface (UI) and a Server. In the user interface you specify the app layout, ie a plot in the middle, and in the server you specify what the plot should look like. The basic set up for a plot object in Shiny is below. 

```{r}
library(shiny)
library(ggplot2)

init_data = data.frame(x = 1:10, y = rep(0,10), shape = rep("A",10)) 
init_data$shape <- factor(init_data$shape, levels = c("A", "B"))

ui <- basicPage(
  plotOutput("plotExample", click = NULL)
)

server <- function(input, output){

  output$plotExample <- renderPlot({
    ggplot(data = init_data) +
      geom_point(aes(x = x, y = y, shape = shape), size = 10) +
      ggtitle("Some simple plot example") +
      theme(legend.position = "none")
  })

}

shinyApp(ui, server)
```

There is currently no interactivity specified yet.

### Mouse Click

Later, we will use the mouse click to test if a person is infected. We will do this by collecting that person's coordinates from a mouse click and passing those coordintes to other variables. 

The goal of the following snippets is to show how to use the information from a mouse click to update plot aesthetics. This requires three basic edits to the above code.

#### (i) Specify the mouse click variable 

To get coordinates from a plot in shiny we can simply change the inputs to the `plotOutput()` function in the user interface. 

```{r eval = FALSE}
ui <- basicPage(plotOutput("plotExample", click = "plot_click"))
```
Now a variable called `input$plot_click` that contains coordinates can be called within the server function.

#### (ii) Create a new reactive variable

To update a variable when something changes, ie. like a mouse is click, we need to use `reactiveValues()`. In our example, this means the data frame that is passed to `renderPlot()` needs to be specified as a reactive variable.

```{r eval = FALSE}
plot <- reactiveValues(data = init_data)
```

The data frame passed to the function `renderPlot()` now also needs updated to our new reactive varialbe, `plot$data`.

```{r eval = FALSE}
output$plotExample <- renderPlot({
    ggplot(data = plot$data) +
      # same as before
  })
```

#### (iii) Make the new variable react

To cause `plot$data` to *react* whenever the mouse is clicked, we need to specify in our code that the the plot has been clicked using `observeEvent()`. The below snippet will changes shape columns in our data frame.

```{r eval = FALSE}
observeEvent(input$plot_click,{
    i = round(as.numeric(input$plot_click$x))
    plot$data$shape[i] = "B"
})
```

#### Result

Putting it all together we get the following update to the shiny app.

```{r}
library(shiny)

init_data = data.frame(x = 1:10, y = rep(0,10), shape = rep("A",10)) 
init_data$shape <- factor(init_data$shape, levels = c("A", "B"))

ui <- basicPage(plotOutput("plotExample", click = "plot_click"))

server <- function(input, output){

  plot <- reactiveValues(data = init_data)
  
  observeEvent(input$plot_click,{
    i = round(as.numeric(input$plot_click$x))
    plot$data$shape[i] = "B"
  })
  
  output$plotExample <- renderPlot({
    ggplot(data = plot$data) +
      geom_point(aes(x = x, y = y, shape = shape), size = 10) +
      ggtitle("Some simple plot example") +
      theme(legend.position = "none")
  })

}

shinyApp(ui, server)
```

### Text

#### Rules 
summary text 

### Winning  
asdf

#### Pop Up Box 
asdf

#### Game Stats
asdf

### Difficulty 
asdf

#### Slider 
asdf

#### Reactivity
asdf

### Hosting Online
asdf

## Why? 

### Inspiration 

When corona began, uncertainty was high and given my mathematical background I had to resist the strong temptation to become an armchair epidemiologist. I still felt this overwhelming desire to explore the aspects of virus sprerad through data visualisation though, so I channelled my energies into creating this shiny app. 

One of the earliest and most influential visualisations of the virus spread was from an [article]('https://www.washingtonpost.com/graphics/2020/world/corona-simulator/') in the Washington Post. I think this visualisation is marvellous and have shared it widely with friends and family. Although, for me something does feel missing in this visualisation, aside from people acting like a pinballs in a pinball machine. It is the capacity to interact, and experiment further with aspects of how virus spread works. A more comprehensive look at some of the variables involved is given in this [youtube video]('https://www.youtube.com/watch?v=gxAaO2rsdIs').

Around the same time, I became aware of the twitter trend [5 jobs you had before you became a scientist]('https://www.nj.com/entertainment/2019/04/what-have-you-done-for-money-in-5-jobs-trend-people-are-sharing-their-work-history-on-twitter.html'). (I love this trend took over a year to reach my clearly, very Australian-centric twitter feed). When I was very young, I used to do administrative chores at my mum's physiotherapy for pocket money. I also played a lot of minesweeper - like a lot.

It was this combination of things that sparked the idea to create [corona sweeper]('https://katerobsau.shinyapps.io/Corona_Sweeper/'). A shiny app where instead of identifying hidden mines, you can use testing to uncover infected individuals in a population. How we choose to test is clearly very important to mitigating virus spread.

### A comment on sensitivity 

So I actually wrote this code during my second week of working from home in the Netherlands. I wasn't being productive at work, and working on a creative idea in R is an outlet for me. I have wanted to share it for a while, but I was worried that people may find it distasteful or disrespectful. Covid-19 is impacting lives and livelihoods. 

There are reasons that have since changed my mind about sharing the game:

(i) I have shared it with friends, and friends with family who have had corona. It bought these people joy and that is what matters.

(ii) I recently had a brief period of self-isolation myself, when two friends in my bubble developed Covid-like symptoms. These friends didn't meet the criteria for testing here in the Netherlands, so we still do not know whether why they have had corona or not. Either way, the game is no longer strictly abstract for me now.

(iii) Game play is a really important tool for learning. I have learnt a lot about the interplay of infection spread, quarantine and testing through playing this simple game. The most interesting part is that even though I am the designer, I didn't know what the optimal strategy. I have only learnt that through gameplay and experimenting with the parameters.

<!-- (iv) The most important point. Some people told me I should make it available through the app store and monetarise it. Turns out I'm a classic academic and don't seek reward for knowledge or hard work. However, I met a wonderful woman from India earlier this year. By following her facebook posts I have realised just how closed my world is to many of the problems faced by people in her country. Her city of Bengal has just been hit by a Cyclone. Given the importance of social distancing to preventing virus spread, the cyclone is going to compound the already very severe impacts of covid-19, such as through increased spread in disaster shelters. So I have decided to put this work towards a good cause, and if you enjoy playing this game please donate [here]('https://www.edexlive.com/news/2020/may/22/amphancyclone-heres-how-you-can-donate-to-relief-funds-to-help-cyclone-ravaged-bengal-and-odisha-12179.html). -->



<!-- You might notice, there is both a levels and labels vector. The levels are to keep the internal code concise and clear. The labels are for what we want to appear in the plot legend.   -->

<!-- For each person we now have an entry in each of the columns: `x`, `y`, `shown`, `quarantined`, `tested` and `hidden`. -->



<!-- ### Reactivity  -->

<!-- Counter  -->

<!-- new infections > infection period > symtpom show >  recovery show > tested > quarantine  -->

<!-- ### How the virus spreads  -->

<!-- Most governments require a period of 14 days in quarantine if you have come into contact with the virus.  -->

<!-- ### Testing  -->

<!-- By clicking on a person, you can test if they have the infection.  -->
<!-- Once a person is revealed as infected, they immediately go into quarantine, along with their four closest neighbours. -->

<!-- ### Winning -->

<!-- ### Optimal Strategy  -->

<!-- I don't know! I made it for fun!  -->


<!-- Each of these grid cells represent a person in the population. -->

<!-- ## Migration -->
<!-- ## Mortality -->
<!-- * shiny mobile -->
<!-- * optimising the probability -->
<!-- (confusing some can recover) -->
